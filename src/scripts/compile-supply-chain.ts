import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import { Abi, Hex } from 'viem';

// Configuration
const TEMP_DIR = path.join(__dirname, '../../temp');
const CONTRACTS_DIR = path.join(__dirname, '../contracts');

// Ensure temp directory exists
if (!fs.existsSync(TEMP_DIR)) {
  fs.mkdirSync(TEMP_DIR, { recursive: true });
}

// Compile contracts
async function compileContracts() {
  try {
    console.log('Compiling contracts...');

    // You'll need to install the NIL Foundation smart contracts first
    // npm install @nilfoundation/smart-contracts --save

    // Create a package.json for solc remappings
    const packageJson = {
      name: "nil-contracts-compilation",
      dependencies: {
        "@nilfoundation/smart-contracts": "^0.1.0"
      }
    };
    fs.writeFileSync(path.join(TEMP_DIR, 'package.json'), JSON.stringify(packageJson, null, 2));

    // Install dependencies in temp directory
    console.log('Installing dependencies...');
    execSync('npm install', { cwd: TEMP_DIR });

    // Set up remappings for solc
    const remappings = [
      `@nilfoundation/=node_modules/@nilfoundation/`
    ].join(',');

    // Compile Retailer contract
    console.log('Compiling Retailer contract...');
    const retailerOutputPath = path.join(TEMP_DIR, 'Retailer.json');
    execSync(`solc --optimize --optimize-runs=200 --combined-json abi,bin --allow-paths ${TEMP_DIR}/node_modules @remappings=${remappings} ${path.join(CONTRACTS_DIR, 'Retailer.sol')} > ${retailerOutputPath}`);

    // Compile Manufacturer contract
    console.log('Compiling Manufacturer contract...');
    const manufacturerOutputPath = path.join(TEMP_DIR, 'Manufacturer.json');
    execSync(`solc --optimize --optimize-runs=200 --combined-json abi,bin --allow-paths ${TEMP_DIR}/node_modules @remappings=${remappings} ${path.join(CONTRACTS_DIR, 'Manufacturer.sol')} > ${manufacturerOutputPath}`);

    // Read compiled outputs
    const retailerOutput = JSON.parse(fs.readFileSync(retailerOutputPath, 'utf8'));
    const manufacturerOutput = JSON.parse(fs.readFileSync(manufacturerOutputPath, 'utf8'));

    // Find the contract keys
    const retailerKey = Object.keys(retailerOutput.contracts).find(
      key => key.endsWith('Retailer.sol:Retailer')
    );
    const manufacturerKey = Object.keys(manufacturerOutput.contracts).find(
      key => key.endsWith('Manufacturer.sol:Manufacturer')
    );

    if (!retailerKey || !manufacturerKey) {
      throw new Error('Could not find compiled contracts in output');
    }

    // Extract bytecode and ABI
    const retailerContract = retailerOutput.contracts[retailerKey];
    const manufacturerContract = manufacturerOutput.contracts[manufacturerKey];

    const retailerBytecode = `0x${retailerContract.bin}`;
    const manufacturerBytecode = `0x${manufacturerContract.bin}`;
    const retailerAbi = JSON.parse(retailerContract.abi);
    const manufacturerAbi = JSON.parse(manufacturerContract.abi);

    console.log('Compiled successfully!');
    console.log(`Retailer bytecode length: ${retailerBytecode.length}`);
    console.log(`Manufacturer bytecode length: ${manufacturerBytecode.length}`);

    // Generate constants file with the bytecode
    const constantsFileContent = `// Auto-generated by compile-supply-chain.ts
export const DEFAULT_SHARD_ID = 1;

// Retailer Contract ABI
export const RETAILER_ABI = ${JSON.stringify(retailerAbi, null, 2)} as const;

// Manufacturer Contract ABI
export const MANUFACTURER_ABI = ${JSON.stringify(manufacturerAbi, null, 2)} as const;

// Retailer Contract Bytecode
export const RETAILER_BYTECODE = "${retailerBytecode}";

// Manufacturer Contract Bytecode
export const MANUFACTURER_BYTECODE = "${manufacturerBytecode}";

// Define contract types and exports
export interface ContractType {
  description: string;
  bytecode: string;
  abi?: readonly any[] | any[];
}

export const CONTRACT_TYPES: Record<string, ContractType> = {
  RETAILER: {
    description: "Retailer contract that can order products from manufacturer",
    bytecode: RETAILER_BYTECODE,
    abi: RETAILER_ABI
  },
  MANUFACTURER: {
    description: "Manufacturer contract that creates products ordered by retailer",
    bytecode: MANUFACTURER_BYTECODE,
    abi: MANUFACTURER_ABI
  }
};`;

    // Write the constants file
    const constantsFilePath = path.join(__dirname, '../action-providers/nil-supply-chain/constants.ts');
    fs.writeFileSync(constantsFilePath, constantsFileContent);
    console.log(`Updated constants file at: ${constantsFilePath}`);

    return {
      retailerBytecode,
      manufacturerBytecode,
      retailerAbi,
      manufacturerAbi
    };
  } catch (error) {
    console.error('Error compiling contracts:', error);
    throw error;
  }
}

async function main() {
  try {
    await compileContracts();
    console.log('Compilation and bytecode extraction completed successfully!');
  } catch (error) {
    console.error('Failed to compile contracts:', error);
    process.exit(1);
  }
}

main(); 